{
    "collab_server" : "",
    "contents" : "#Layout server\n\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(ggplot2)\nrequire(plyr)\nlibrary(DT)\nlibrary(Rcpp)\nsourceCpp('rcpp_examples.cpp')\nlibrary(invgamma)\n#transit <- read.csv(\"\\Transit_demand.csv\",header=TRUE,sep=\",\")\n\nshinyserver <- function(input, output) {\n##############################################    Tarea 1     ##########################################################################################  \n \n  rExp <- function(simu, lamb){\n    lamb <- (input$lambda)\n    \n    return((-1/lamb)*log(1-runif(simu)))\n  }\n  \n   output$plot1 <- renderPlot({\n    lamb <- (input$lambda)\n    simu <- (input$Simulaciones)\n  \n   \n    dat <- data.frame(Value=rExp(simu, lamb))\n    ggplot(dat, aes(x=Value)) +\n      geom_histogram(aes(y=..density..), binwidth= .2, colour=\"black\", fill=\"white\") +\n      stat_function(fun = function(x) lamb*exp(-lamb*x),colour = \"blue\")\n  })\n  \n  output$value <- renderPrint({ \n    lamb <- (input$lambda)\n    simu <- (input$Simulaciones)\n    alp<-(input$alp)\n    set.seed(166940)\n\n    print(ks.test(rExp(simu, lamb), pexp, lamb))\n\n    pv<-ks.test(rExp(simu, lamb), pexp, lamb)$p.value\n        \n    if(pv<=alp){\n      print( paste(\"Los datos no se comportan exponencial con lambda:\", lamb, \"y alpha:\",alp))\n    }else{\n      print(paste(\"Es un buen supuesto que los datos se comportan de manera exponencial con lambda:\",lamb, \"y alpha:\",alp))\n    }\n    })\n\n##############################################    Tarea 2     #########################################################################################  \n\n    fun1 <- reactive({\n      texto <- paste(\"aux <- \", input$expresion1)\n      eval(parse(text=texto))\n      aux\n  })\n  \n \n \n  \n  output$Integracion <- renderPrint({\n    \n    ####Parametros introducidos por el usuarios\n    step<-input$NN\n    diezstep<- 10*step\n    Phi<-fun1()\n    X.dens <- function(nsim) runif(nsim, input$N1,input$N2)\n    N <- seq(step,diezstep,step)\n    al<-input$alpha\n    k<-input$N2-input$N1\n    \n    \n    ####Formula para el calculo de la integral\n    mc.intervals <- function(Phi, N, X.dens,al=.05,k=1){\n      set.seed(166940)\n      results.list <- lapply(N, function(nsim){\n        X <- sapply(FUN=X.dens, nsim) # N samples of the density of X\n        PhiX <- sapply(X, Phi) # Evaluate phi at each X_i\n        estim <- mean(PhiX) # Estimate of int_a^b \\phi(x)f(x)df=E[phi(X_i)]\n        S2 <- var(PhiX) # Estimate of the variance of phi(X_i)\n        quant <- qnorm(al/2, lower.tail=FALSE) # Right quantile for alpha/2\n        int.upper <- k*estim + sqrt(S2/nsim)*quant # Upper confidence interval\n        int.lower <- k*estim - sqrt(S2/nsim)*quant # Lower confidence interval\n        return(data.frame(Muestra=nsim, Estimado=k*estim, LI=int.lower, UI=int.upper))\n        # -------\n      })\n      #\n      results.table <- ldply(results.list) # Assembles list in data.frame\n      return(results.table)\n    }\n    \n    \n    ####Caculo de la funcion\n    data <- mc.intervals(Phi=Phi, N=N, X.dens=X.dens)[1,]\n    \n    \n    print(\"El resultado de la integral se presenta en el campo Estimado\")\n    print(data)\n    \n    })\n  \n  ####Grafico de la funcion\n  output$plot2<-renderPlot({\n  \n    plot(fun1(),input$N1,input$N2,type='l',col=\"blue\",xlab=\"x\",ylab=\"f(x)\")\n     \n    \n    })\n  \n  # ####Grafico de la funcion de los intervalos de confianza\n   output$plot3<-renderPlot({\n     \n     ####Parametros introducidos por el usuarios\n     step<-input$NN\n     diezstep<- 10*step\n     Phi<-fun1()\n     X.dens <- function(nsim) runif(nsim, input$N1,input$N2)\n     N <- seq(step,diezstep,step)\n     al<-input$alpha\n     k<-input$N2-input$N1\n     \n     \n     ####Formula para el calculo de la integral\n     mc.intervals <- function(Phi, N, X.dens,al=.05,k=1){\n       set.seed(166940)\n       results.list <- lapply(N, function(nsim){\n         X <- sapply(FUN=X.dens, nsim) # N samples of the density of X\n         PhiX <- sapply(X, Phi) # Evaluate phi at each X_i\n         estim <- mean(PhiX) # Estimate of int_a^b \\phi(x)f(x)df=E[phi(X_i)]\n         S2 <- var(PhiX) # Estimate of the variance of phi(X_i)\n         quant <- qnorm(al/2, lower.tail=FALSE) # Right quantile for alpha/2\n         int.upper <- k*estim + sqrt(S2/nsim)*quant # Upper confidence interval\n         int.lower <- k*estim - sqrt(S2/nsim)*quant # Lower confidence interval\n         return(data.frame(Muestra=nsim, Estimado=k*estim, LI=int.lower, UI=int.upper))\n         # -------\n       })\n       #\n       results.table <- ldply(results.list) # Assembles list in data.frame\n       return(results.table)\n     }\n     \n     \n     ####Caculo de la funcion\n     datafull <- mc.intervals(Phi=Phi, N=N, X.dens=X.dens)\n     \n   ggplot(datafull, aes(x=Muestra)) +\n   geom_ribbon(aes(ymin=LI, ymax=UI), fill=\"grey\") +\n   geom_line(aes(y=Estimado), colour=\"blue\") \n   })\n\n##############################################    Tarea 3     #########################################################################################     \n   \n   \n\n   MatT <- reactive({\n     inFile<-input$archi\n     Matriz <- read.csv(inFile$datapath, header=FALSE, sep=\",\")\n     Matriz<-as.matrix(Matriz)\n     dimnames(Matriz)<-list(seq(1,dim(Matriz)[1],1),seq(1,dim(Matriz)[1],1))\n     Matriz\n     })\n\n\n   \n   output$corrida <- renderPrint({\n \n     lamat<-MatT()\n     camino<-markovchain_trajectory(init_state=input$inicio, n_transitions=input$trans, trans_mat=lamat)\n     print(camino)\n\n   })\n   \n   output$tabla<-renderDataTable(matriz<-MatT()\n                                 )\n   \n##############################################    Tarea 4    #########################################################################################     \n\n   \n   ArCSV <- reactive({\n     inFile <-input$archivo\n     transit <- read.csv(inFile$datapath, header=TRUE, sep=\",\")\n     #Matriz2 <-as.matrix(Matriz2)\n     #dimnames(Matriz)<-list(seq(1,dim(Matriz)[1],1),seq(1,dim(Matriz)[1],1))\n     return (transit)\n   })\n   \n   output$mytrans<-renderDataTable(ArCSV())\n                                 \n   \n   #Base de datos para la regresion   \n   #output$mytrans <- DT::renderDataTable({\n   # DT::datatable(transit)\n   #})\n   \n   #Scatterplot\n   \n   output$dispersion<-renderPlot({\n     \n     a=3\n     b=6\n     for (i in(2:6)){\n       if (input$variableX== i) {a=i} \n       if (input$variableY== i) {b=i} \n     }\n     \n     datafrm <- ArCSV()\n     \n     #equis<-transit[,a]\n     equis<-datafrm[,a] \n     #ye<-transit[,b]\n     ye<-datafrm[,b]\n     sp<-data.frame(equis,ye)\n     \n     \n     ggplot(sp, aes(x=equis, y=ye)) +\n       geom_point(shape=1) +  \n       geom_smooth(method = lm) #De repente dejo de pintar la recta de la regresion\n   })\n   \n#Aprioris\n   \n   output$aprioris <- renderPrint({\n     \n     a=3\n     b=6\n     for (i in(2:6)){\n       if (input$variableX== i) {a=i} \n       if (input$variableY== i) {b=i} \n     }\n     \n     datafrm <- ArCSV()\n     \n     \n     #equis<-c(transit[,a])\n     equis<-c(datafrm[,a])\n     #ye<-c(transit[,b])\n     ye<-c(datafrm[,b])\n     sp<-data.frame(equis,ye)\n     splm<-lm(ye~equis,data=sp)\n     summary_splm<-summary(splm)\n     betas<-coefficients(summary_splm)\n     \n     \n     print(paste(\" b0~Normal(\",round(betas[1,1],digits=2), \",\",round(betas[1,2],digits=2),\")\"))\n     print(paste(\" b1~Normal(\",round(betas[2,1],digits=2), \",\",round(betas[2,2],digits=2),\")\"))\n     print(paste(\" sigma^2~InvGamma(\",27/2, \",\",round(25*summary_splm$sigma,digits=2),\")\"))\n     \n     \n   })\n   \n #graficas aprioris\n   \n  \n   output$apriori1 <- renderPlot({\n     a=3\n     b=6\n     for (i in(2:6)){\n       if (input$variableX== i) {a=i} \n       if (input$variableY== i) {b=i} \n     }\n     \n     datafrm <- ArCSV()\n     \n     #equis<-c(transit[,a])\n     equis<-c(datafrm[,a])\n     #ye<-c(transit[,b])\n     ye<-c(datafrm[,b])\n     sp<-data.frame(equis,ye)\n     splm<-lm(ye~equis,data=sp)\n     summary_splm<-summary(splm)\n     betas<-coefficients(summary_splm)\n     \n     x <- seq(-25, 25, length=100)\n     plot(x, dnorm(x,round(betas[1,1],digits=2),round(betas[1,2],digits=2)), type=\"l\", lty=2, xlab=\"x value\",\n          ylab=\"Density\", main= paste(\"Apriori b0~Normal(\",round(betas[1,1],digits=2), \",\",round(betas[1,2],digits=2),\")\"))\n     \n   })\n   output$apriori2 <- renderPlot({\n     a=3\n     b=6\n     for (i in(2:6)){\n       if (input$variableX== i) {a=i} \n       if (input$variableY== i) {b=i} \n     }\n     \n     datafrm <- ArCSV()\n     \n     #equis<-c(transit[,a])\n     equis<-c(datafrm[,a])\n     #ye<-c(transit[,b])\n     ye<-c(datafrm[,b])\n     \n     sp<-data.frame(equis,ye)\n     splm<-lm(ye~equis,data=sp)\n     summary_splm<-summary(splm)\n     betas<-coefficients(summary_splm)\n     \n     x <- seq(-25, 25, length=100)\n     plot(x, dnorm(x,round(betas[2,1],digits=2),round(betas[2,2],digits=2)), type=\"l\", lty=2, xlab=\"x value\",\n          ylab=\"Density\", main= paste(\"Apriori b0~Normal(\",round(betas[2,1],digits=2), \",\",round(betas[2,2],digits=2),\")\"))\n     \n   })\n   output$apriori3 <- renderPlot({\n     a=3\n     b=6\n     for (i in(2:6)){\n       if (input$variableX== i) {a=i} \n       if (input$variableY== i) {b=i} \n     }\n     \n     datafrm <- ArCSV()\n     \n     #equis<-c(transit[,a])\n     equis<-c(datafrm[,a])\n     #ye<-c(transit[,b])\n     ye<-c(datafrm[,b])\n     \n     sp<-data.frame(equis,ye)\n     splm<-lm(ye~equis,data=sp)\n     summary_splm<-summary(splm)\n     betas<-coefficients(summary_splm)\n     \n     x <- seq(-25, 25, length=100)\n     plot(x, dinvgamma(x,13.5,round(25*summary_splm$sigma,digits=2)), type=\"l\", lty=2, xlab=\"x value\",\n          ylab=\"Density\", main=paste(\" sigma^2~InvGamma(\",27/2, \",\",round(25*summary_splm$sigma,digits=2),\")\"))\n   })\n   \n################################### Tarea 5 #######################################   \n   \n   selecciones<-reactive({\n     \n     a=3\n     b=6\n     for (i in(2:6)){\n       if (input$variableX== i) {a=i} \n       if (input$variableY== i) {b=i} \n     }\n     \n     datafrm <- ArCSV()\n     \n     #equis<-c(transit[,a])\n     equis<-c(datafrm[,a])\n     #ye<-c(transit[,b])\n     ye<-c(datafrm[,b])\n     \n     list('x'=equis,'y'=ye)  \n     \n   })\n   \n\n   nreg <- reactive({\n     \n     sp<-data.frame(selecciones()$x,selecciones()$y)\n     splm<-lm(selecciones()$y~selecciones()$x,data=sp)\n     summary_splm<-summary(splm)\n     betas<-coefficients(summary_splm)\n     list('betas' = betas, 'summary' = summary_splm)\n   })\n   \n  \n     \n     likelihood <- function(param){\n       b1= param[1]\n       b0 = param[2]\n       sigma2 = param[3]\n       \n       pred = b1*selecciones()$x + b0\n       singlelikelihoods = dnorm(selecciones()$y, mean = pred, sd = sigma2**.5, log = T)\n       sumll = sum(singlelikelihoods)\n       return(sumll)   \n     }\n     \n     prior <- function(param){\n       b1 = param[1]\n       b0 = param[2]\n       sigma2 = param[3]\n       b1prior = dnorm(b1, mean=round(nreg()$betas[1,1],digits=2), sd=round(nreg()$betas[1,2]**.5,digits=2), log = T)\n       b0prior = dnorm(b0, mean=round(nreg()$betas[2,1],digits=2), sd=round(nreg()$betas[2,2]**.5,digits=2), log = T)\n       sigma2prior = dinvgamma(sigma2,14,round(25*nreg()$summary$sigma,digits=2),log = T)\n       return(b1prior+b0prior+sigma2prior)\n     }\n     \n     posterior <- function(param){\n       return (likelihood(param) + prior(param))\n     }\n     \n     ######## Metropolis algorithm ################\n     \n     proposalfunction <- function(param){\n       return(rnorm(3,mean = param, sd= c(0.1,0.5,0.3)))\n     }\n     \n     run_metropolis_MCMC <- function(startvalue, iterations){\n       chain = array(dim = c(iterations+1,3))\n       chain[1,] = startvalue\n       for (i in 1:iterations){\n         proposal = proposalfunction(chain[i,])\n         \n         logprobab =posterior(proposal) - posterior(chain[i,])\n         if (log(runif(1)) <= logprobab){\n           chain[i+1,] = proposal\n         }else{\n           chain[i+1,] = chain[i,]\n         }\n       }\n       return(chain)\n     }\n     \n     #correle<-eventReactive(input$button,{ \n     resmcmc<-eventReactive(input$button,{\n       \n       \n     startvalue = c(rnorm(1,0,1),rnorm(1,0,1),rinvgamma(1,1,1))\n     chain = run_metropolis_MCMC(startvalue, input$numcad)\n     chain=data.frame(b1=chain[,1],b0=chain[,2],s2=chain[,3])\n      \n     if(input$longcad>1){ \n     for (i in 2:input$longcad){\n       \n       startvalue = c(rnorm(1,0,1),rnorm(1,0,1),rinvgamma(1,1,1))\n       chain2 = run_metropolis_MCMC(startvalue, input$numcad)\n       chain2=data.frame(b1=chain2[,1],b0=chain2[,2],s2=chain2[,3])\n       chain=cbind(chain,chain2)\n       \n     }}\n     \n      return(chain)\n     })\n     \n     \n     #for (i in 2:input$longcad){\n     # startvalue = c(rnorm(1,0,1),rnorm(1,0,1),rinvgamma(1,1,1))\n     #chain = run_metropolis_MCMC(startvalue, input$numcad)\n     #newchain<-data.frame(b1=chain[,1],b0=chain[,2],s2=chain[,3])\n     #lachain<-cbind(lachain,newchain)\n     #}\n     \n     output$cadenas<-renderDataTable({ \n      resmcmc()\n   })   \n   \n  \n   \n   \n   output$histos<-renderPlot({\n     \n     burnIn = input$numcad*.20\n     acceptance = 1-mean(duplicated(resmcmc()[-(1:burnIn),]))\n     par(mfrow = c(2,3))\n     hist(resmcmc()[-(1:burnIn),1],nclass=30,  main=\"Posterior of b1\", xlab=\"Parametro\" )\n     abline(v = mean(resmcmc()[-(1:burnIn),1]))\n     hist(resmcmc()[-(1:burnIn),2],nclass=30, main=\"Posterior of b0\", xlab=\"Parametro\")\n     abline(v = mean(resmcmc()[-(1:burnIn),2]))\n     hist(resmcmc()[-(1:burnIn),3],nclass=30, main=\"Posterior of sigma^2\", xlab=\"Parametro\")\n     abline(v = mean(resmcmc()[-(1:burnIn),3]) )\n     plot(resmcmc()[-(1:burnIn),1], type = \"l\", xlab=\"Iteraciones\" , main = \"Chain values of b1\" )\n     plot(resmcmc()[-(1:burnIn),2], type = \"l\", xlab=\"Iteraciones\" , main = \"Chain values of b0\")\n     plot(resmcmc()[-(1:burnIn),3], type = \"l\", xlab=\"Iteraciones\" , main = \"Chain values of sigma^2\")\n     \n        })\n   \n   output$distos<-renderPlot({\n     \n     burnIn = input$numcad*.20\n  \n     par(mfrow = c(1,3))\n     \n     d1 <- density(resmcmc()[-(1:burnIn),1])\n     d2 <- density(resmcmc()[-(1:burnIn),2])\n     d3 <- density(resmcmc()[-(1:burnIn),3])\n     \n     plot(d1,main = \"Posteriori of b1\")\n     plot(d2,main = \"Posteriori of b0\")\n     plot(d3,main = \"Posteriori of sigma^2\")\n     \n     \n     \n     \n   })\n   \n}\n\n\n\n",
    "created" : 1481913828923.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "750620457",
    "id" : "2AA44BB9",
    "lastKnownWriteTime" : 1481916127,
    "last_content_update" : 1481916127971,
    "path" : "~/Downloads/compstat2016-master/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}